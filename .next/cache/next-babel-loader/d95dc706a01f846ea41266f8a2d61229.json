{"ast":null,"code":"\"use strict\";var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _slicedToArray=require(\"@babel/runtime/helpers/slicedToArray\");var _extends=require(\"@babel/runtime/helpers/extends\");function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);if(enumerableOnly)symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable;});keys.push.apply(keys,symbols);}return keys;}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=arguments[i]!=null?arguments[i]:{};if(i%2){ownKeys(Object(source),true).forEach(function(key){_defineProperty(target,key,source[key]);});}else if(Object.getOwnPropertyDescriptors){Object.defineProperties(target,Object.getOwnPropertyDescriptors(source));}else{ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key));});}}return target;}function _createForOfIteratorHelper(o,allowArrayLike){var it;if(typeof Symbol===\"undefined\"||o[Symbol.iterator]==null){if(Array.isArray(o)||(it=_unsupportedIterableToArray(o))||allowArrayLike&&o&&typeof o.length===\"number\"){if(it)o=it;var i=0;var F=function F(){};return{s:F,n:function n(){if(i>=o.length)return{done:true};return{done:false,value:o[i++]};},e:function e(_e){throw _e;},f:F};}throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");}var normalCompletion=true,didErr=false,err;return{s:function s(){it=o[Symbol.iterator]();},n:function n(){var step=it.next();normalCompletion=step.done;return step;},e:function e(_e2){didErr=true;err=_e2;},f:function f(){try{if(!normalCompletion&&it[\"return\"]!=null)it[\"return\"]();}finally{if(didErr)throw err;}}};}function _unsupportedIterableToArray(o,minLen){if(!o)return;if(typeof o===\"string\")return _arrayLikeToArray(o,minLen);var n=Object.prototype.toString.call(o).slice(8,-1);if(n===\"Object\"&&o.constructor)n=o.constructor.name;if(n===\"Map\"||n===\"Set\")return Array.from(o);if(n===\"Arguments\"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))return _arrayLikeToArray(o,minLen);}function _arrayLikeToArray(arr,len){if(len==null||len>arr.length)len=arr.length;for(var i=0,arr2=new Array(len);i<len;i++){arr2[i]=arr[i];}return arr2;}exports.__esModule=true;exports[\"default\"]=prepareDestination;var _querystring=require(\"./querystring\");var _parseRelativeUrl=require(\"./parse-relative-url\");var pathToRegexp=_interopRequireWildcard(require(\"next/dist/compiled/path-to-regexp\"));function _getRequireWildcardCache(){if(typeof WeakMap!==\"function\")return null;var cache=new WeakMap();_getRequireWildcardCache=function _getRequireWildcardCache(){return cache;};return cache;}function _interopRequireWildcard(obj){if(obj&&obj.__esModule){return obj;}if(obj===null||typeof obj!==\"object\"&&typeof obj!==\"function\"){return{\"default\":obj};}var cache=_getRequireWildcardCache();if(cache&&cache.has(obj)){return cache.get(obj);}var newObj={};var hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var key in obj){if(Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;if(desc&&(desc.get||desc.set)){Object.defineProperty(newObj,key,desc);}else{newObj[key]=obj[key];}}}newObj[\"default\"]=obj;if(cache){cache.set(obj,newObj);}return newObj;}function prepareDestination(destination,params,query,appendParamsToQuery,basePath){var parsedDestination={};query=_extends({},query);delete query.__nextLocale;if(destination.startsWith('/')){parsedDestination=(0,_parseRelativeUrl.parseRelativeUrl)(destination);}else{var _URL=new URL(destination),pathname=_URL.pathname,searchParams=_URL.searchParams,hash=_URL.hash,hostname=_URL.hostname,port=_URL.port,protocol=_URL.protocol,search=_URL.search,href=_URL.href;parsedDestination={pathname:pathname,query:(0,_querystring.searchParamsToUrlQuery)(searchParams),hash:hash,protocol:protocol,hostname:hostname,port:port,search:search,href:href};}var destQuery=parsedDestination.query;var destPath=\"\".concat(parsedDestination.pathname).concat(parsedDestination.hash||'');var destPathParamKeys=[];pathToRegexp.pathToRegexp(destPath,destPathParamKeys);var destPathParams=destPathParamKeys.map(function(key){return key.name;});var destinationCompiler=pathToRegexp.compile(destPath,{validate:false});var newUrl;for(var _i=0,_Object$entries=Object.entries(destQuery);_i<_Object$entries.length;_i++){var _Object$entries$_i=_slicedToArray(_Object$entries[_i],2),key=_Object$entries$_i[0],strOrArray=_Object$entries$_i[1];var value=Array.isArray(strOrArray)?strOrArray[0]:strOrArray;if(value){value=\"/\".concat(value);var queryCompiler=pathToRegexp.compile(value,{validate:false});value=queryCompiler(params).substr(1);}destQuery[key]=value;}var paramKeys=Object.keys(params);if(appendParamsToQuery&&!paramKeys.some(function(key){return destPathParams.includes(key);})){var _iterator=_createForOfIteratorHelper(paramKeys),_step;try{for(_iterator.s();!(_step=_iterator.n()).done;){var _key=_step.value;if(!(_key in destQuery)){destQuery[_key]=params[_key];}}}catch(err){_iterator.e(err);}finally{_iterator.f();}}var shouldAddBasePath=destination.startsWith('/')&&basePath;try{newUrl=\"\".concat(shouldAddBasePath?basePath:'').concat(destinationCompiler(params));var _newUrl$split=newUrl.split('#'),_newUrl$split2=_slicedToArray(_newUrl$split,2),_pathname=_newUrl$split2[0],_hash=_newUrl$split2[1];parsedDestination.pathname=_pathname;parsedDestination.hash=\"\".concat(_hash?'#':'').concat(_hash||'');delete parsedDestination.search;}catch(err){if(err.message.match(/Expected .*? to not repeat, but got an array/)){throw new Error(\"To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match\");}throw err;}parsedDestination.query=_objectSpread(_objectSpread({},query),parsedDestination.query);return{newUrl:newUrl,parsedDestination:parsedDestination};}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["parsedDestination","query","Object","destination","pathname","hash","protocol","hostname","port","search","href","destQuery","destPath","destPathParamKeys","pathToRegexp","destPathParams","key","destinationCompiler","validate","value","Array","strOrArray","queryCompiler","paramKeys","appendParamsToQuery","params","shouldAddBasePath","newUrl","err"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  delete query.__nextLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}