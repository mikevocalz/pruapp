{"ast":null,"code":"\"use strict\";exports.__esModule=true;exports.parseRelativeUrl=parseRelativeUrl;var _utils=require(\"../../utils\");var _querystring=require(\"./querystring\");var DUMMY_BASE=new URL(false?'http://n':(0,_utils.getLocationOrigin)());function parseRelativeUrl(url,base){var resolvedBase=base?new URL(base,DUMMY_BASE):DUMMY_BASE;var _URL=new URL(url,resolvedBase),pathname=_URL.pathname,searchParams=_URL.searchParams,search=_URL.search,hash=_URL.hash,href=_URL.href,origin=_URL.origin,protocol=_URL.protocol;if(origin!==DUMMY_BASE.origin||protocol!=='http:'&&protocol!=='https:'){throw new Error('invariant: invalid relative URL');}return{pathname:pathname,query:(0,_querystring.searchParamsToUrlQuery)(searchParams),search:search,hash:hash,href:href.slice(DUMMY_BASE.origin.length)};}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/parse-relative-url.ts"],"names":["DUMMY_BASE","resolvedBase","base","origin","protocol","pathname","query","search","hash","href"],"mappings":"+EAAA,GAAA,CAAA,MAAA,CAAA,OAAA,eAAA,CACA,GAAA,CAAA,YAAA,CAAA,OAAA,iBAAA,CAEA,GAAMA,CAAAA,UAAU,CAAG,GAAA,CAAA,GAAA,CACjB,MAAA,UAAA,CAA6C,CAAA,EAAA,MAAA,CAD/C,iBAC+C,GAD5B,CAAnB,CAUO,QAAA,CAAA,gBAAA,CAAA,GAAA,CAAA,IAAA,CAAsD,CAC3D,GAAMC,CAAAA,YAAY,CAAGC,IAAI,CAAG,GAAA,CAAA,GAAA,CAAA,IAAA,CAAH,UAAG,CAAH,CAAzB,UAAA,CAD2D,SAUvD,GAAA,CAAA,GAAA,CAAA,GAAA,CARJ,YAQI,CAVuD,CAErD,QAFqD,MAErD,QAFqD,CAErD,YAFqD,MAErD,YAFqD,CAErD,MAFqD,MAErD,MAFqD,CAErD,IAFqD,MAErD,IAFqD,CAErD,IAFqD,MAErD,IAFqD,CAErD,MAFqD,MAErD,MAFqD,CAErD,QAFqD,MAErD,QAFqD,CAW3D,GACEC,MAAM,GAAKH,UAAU,CAArBG,MAAAA,EACCC,QAAQ,GAARA,OAAAA,EAAwBA,QAAQ,GAFnC,QAAA,CAGE,CACA,KAAM,IAAA,CAAA,KAAA,CAAN,iCAAM,CAAN,CAEF,OAAO,CACLC,QADK,CACLA,QADK,CAELC,KAAK,CAAE,CAAA,EAAA,YAAA,CAAA,sBAAA,EAFF,YAEE,CAFF,CAGLC,MAHK,CAGLA,MAHK,CAILC,IAJK,CAILA,IAJK,CAKLC,IAAI,CAAEA,IAAI,CAAJA,KAAAA,CAAWT,UAAU,CAAVA,MAAAA,CALnB,MAKQS,CALD,CAAP,CAOD","sourcesContent":["import { getLocationOrigin } from '../../utils'\nimport { searchParamsToUrlQuery } from './querystring'\n\nconst DUMMY_BASE = new URL(\n  typeof window === 'undefined' ? 'http://n' : getLocationOrigin()\n)\n\n/**\n * Parses path-relative urls (e.g. `/hello/world?foo=bar`). If url isn't path-relative\n * (e.g. `./hello`) then at least base must be.\n * Absolute urls are rejected with one exception, in the browser, absolute urls that are on\n * the current origin will be parsed as relative\n */\nexport function parseRelativeUrl(url: string, base?: string) {\n  const resolvedBase = base ? new URL(base, DUMMY_BASE) : DUMMY_BASE\n  const {\n    pathname,\n    searchParams,\n    search,\n    hash,\n    href,\n    origin,\n    protocol,\n  } = new URL(url, resolvedBase)\n  if (\n    origin !== DUMMY_BASE.origin ||\n    (protocol !== 'http:' && protocol !== 'https:')\n  ) {\n    throw new Error('invariant: invalid relative URL')\n  }\n  return {\n    pathname,\n    query: searchParamsToUrlQuery(searchParams),\n    search,\n    hash,\n    href: href.slice(DUMMY_BASE.origin.length),\n  }\n}\n"]},"metadata":{},"sourceType":"script"}