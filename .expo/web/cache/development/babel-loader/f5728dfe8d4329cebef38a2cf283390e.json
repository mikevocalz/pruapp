{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"@babel/runtime/helpers/inherits\");\n\nvar _possibleConstructorReturn = require(\"@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"@babel/runtime/helpers/getPrototypeOf\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports[\"default\"] = void 0;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _reactNative = require(\"react-native-web/dist/index\");\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj[\"default\"] = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar KeyboardManager = function (_React$Component) {\n  _inherits(KeyboardManager, _React$Component);\n\n  var _super = _createSuper(KeyboardManager);\n\n  function KeyboardManager() {\n    var _this;\n\n    _classCallCheck(this, KeyboardManager);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"previouslyFocusedTextInput\", null);\n\n    _defineProperty(_assertThisInitialized(_this), \"startTimestamp\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"keyboardTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"clearKeyboardTimeout\", function () {\n      if (_this.keyboardTimeout !== undefined) {\n        clearTimeout(_this.keyboardTimeout);\n        _this.keyboardTimeout = undefined;\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeStart\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _reactNative.TextInput.State.currentlyFocusedInput ? _reactNative.TextInput.State.currentlyFocusedInput() : _reactNative.TextInput.State.currentlyFocusedField();\n\n      _reactNative.TextInput.State.blurTextInput(input);\n\n      _this.previouslyFocusedTextInput = input;\n      _this.startTimestamp = Date.now();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeConfirm\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _this.previouslyFocusedTextInput;\n\n      if (input) {\n        if (_reactNative.Platform.OS === 'android') {\n          _reactNative.Keyboard.dismiss();\n        } else {\n          _reactNative.TextInput.State.blurTextInput(input);\n        }\n      }\n\n      _this.previouslyFocusedTextInput = null;\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"handlePageChangeCancel\", function () {\n      if (!_this.props.enabled) {\n        return;\n      }\n\n      _this.clearKeyboardTimeout();\n\n      var input = _this.previouslyFocusedTextInput;\n\n      if (input) {\n        if (Date.now() - _this.startTimestamp < 100) {\n          _this.keyboardTimeout = setTimeout(function () {\n            _reactNative.TextInput.State.focusTextInput(input);\n\n            _this.previouslyFocusedTextInput = null;\n          }, 100);\n        } else {\n          _reactNative.TextInput.State.focusTextInput(input);\n\n          _this.previouslyFocusedTextInput = null;\n        }\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(KeyboardManager, [{\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.clearKeyboardTimeout();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return this.props.children({\n        onPageChangeStart: this.handlePageChangeStart,\n        onPageChangeConfirm: this.handlePageChangeConfirm,\n        onPageChangeCancel: this.handlePageChangeCancel\n      });\n    }\n  }]);\n\n  return KeyboardManager;\n}(React.Component);\n\nexports[\"default\"] = KeyboardManager;","map":{"version":3,"sources":["KeyboardManager.tsx"],"names":["React","clearTimeout","input","TextInput","Date","Platform","Keyboard","setTimeout","onPageChangeStart","onPageChangeConfirm","onPageChangeCancel","handlePageChangeCancel"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { TextInput, Platform, Keyboard } from 'react-native';\n\ntype Props = {\n  enabled: boolean;\n  children: (props: {\n    onPageChangeStart: () => void;\n    onPageChangeConfirm: () => void;\n    onPageChangeCancel: () => void;\n  }) => React.ReactNode;\n};\n\nexport default class KeyboardManager extends React.Component<Props> {\n  componentWillUnmount() {\n    this.clearKeyboardTimeout();\n  }\n\n  // Numeric id of the previously focused text input\n  // When a gesture didn't change the tab, we can restore the focused input with this\n  private previouslyFocusedTextInput: any | null = null;\n  private startTimestamp: number = 0;\n  private keyboardTimeout: any;\n\n  private clearKeyboardTimeout = () => {\n    if (this.keyboardTimeout !== undefined) {\n      clearTimeout(this.keyboardTimeout);\n      this.keyboardTimeout = undefined;\n    }\n  };\n\n  private handlePageChangeStart = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input: any = TextInput.State.currentlyFocusedInput\n      ? TextInput.State.currentlyFocusedInput()\n      : TextInput.State.currentlyFocusedField();\n\n    // When a page change begins, blur the currently focused input\n    TextInput.State.blurTextInput(input);\n\n    // Store the id of this input so we can refocus it if change was cancelled\n    this.previouslyFocusedTextInput = input;\n\n    // Store timestamp for touch start\n    this.startTimestamp = Date.now();\n  };\n\n  private handlePageChangeConfirm = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      if (Platform.OS === 'android') {\n        Keyboard.dismiss();\n      } else {\n        TextInput.State.blurTextInput(input);\n      }\n    }\n\n    // Cleanup the ID on successful page change\n    this.previouslyFocusedTextInput = null;\n  };\n\n  private handlePageChangeCancel = () => {\n    if (!this.props.enabled) {\n      return;\n    }\n\n    this.clearKeyboardTimeout();\n\n    // The page didn't change, we should restore the focus of text input\n    const input = this.previouslyFocusedTextInput;\n\n    if (input) {\n      // If the interaction was super short we should make sure keyboard won't hide again.\n\n      // Too fast input refocus will result only in keyboard flashing on screen and hiding right away.\n      // During first ~100ms keyboard will be dismissed no matter what,\n      // so we have to make sure it won't interrupt input refocus logic.\n      // That's why when the interaction is shorter than 100ms we add delay so it won't hide once again.\n      // Subtracting timestamps makes us sure the delay is executed only when needed.\n      if (Date.now() - this.startTimestamp < 100) {\n        this.keyboardTimeout = setTimeout(() => {\n          TextInput.State.focusTextInput(input);\n          this.previouslyFocusedTextInput = null;\n        }, 100);\n      } else {\n        TextInput.State.focusTextInput(input);\n        this.previouslyFocusedTextInput = null;\n      }\n    }\n  };\n\n  render() {\n    return this.props.children({\n      onPageChangeStart: this.handlePageChangeStart,\n      onPageChangeConfirm: this.handlePageChangeConfirm,\n      onPageChangeCancel: this.handlePageChangeCancel,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}